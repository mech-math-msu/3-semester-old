[
    {
        "keyword": "алфавит символы буквы слово длина слова конкатенация слов }$.\n\nподмножества $\\sigma^{ словарные множества языки",
        "data": "**Определение:**<a name=\"definition-0\"></a>\n\n*Алфавит* -- это некоторое множество, его элементы -- *символы* или *буквы*.\n\n*Слово* в алфавите $\\Sigma$ -- это конечная последовательность символов.\n\n*Длина слова* -- это количество элементов в последовательности символов, составляющей слово.\n\nСлово нулевой длины обозначается $\\varepsilon$.\n\nЕсли $w_1$ и $w_2$ слова в некотором алфавите, то слово $w_1w_2$, полученное приписыванием $w_2$ в конец $w_1$ -- *конкатенация слов*.\n\nЕсли $w$ -- слово и $n \\in \\mathbb{N}$, то $x^n$ -- это $\\underbrace{x\\ldots x}_{n}$. $x^0 \\rightleftharpoons \\varepsilon$.\n\nМножество всех слов в алфавите $\\Sigma$ обозначается $\\Sigma^{*}$.\n\nПодмножества $\\Sigma^{*}$ -- *словарные множества* или *языки*.\n\n",
        "data_type": "definition",
        "url": "lection-predicate-logic-formal-languages.html#definition-0",
        "html": "<p><strong><a href=\"lection-predicate-logic-formal-languages.html#definition-0\">Определение:</a></strong></p>\n<p><em>Алфавит</em> – это некоторое множество, его элементы –\n<em>символы</em> или <em>буквы</em>.</p>\n<p><em>Слово</em> в алфавите <span class=\"math inline\">\\(\\Sigma\\)</span>\n– это конечная последовательность символов.</p>\n<p><em>Длина слова</em> – это количество элементов в последовательности\nсимволов, составляющей слово.</p>\n<p>Слово нулевой длины обозначается <span\nclass=\"math inline\">\\(\\varepsilon\\)</span>.</p>\n<p>Если <span class=\"math inline\">\\(w_1\\)</span> и <span\nclass=\"math inline\">\\(w_2\\)</span> слова в некотором алфавите, то слово\n<span class=\"math inline\">\\(w_1w_2\\)</span>, полученное приписыванием\n<span class=\"math inline\">\\(w_2\\)</span> в конец <span\nclass=\"math inline\">\\(w_1\\)</span> – <em>конкатенация слов</em>.</p>\n<p>Если <span class=\"math inline\">\\(w\\)</span> – слово и <span\nclass=\"math inline\">\\(n \\in \\mathbb{N}\\)</span>, то <span\nclass=\"math inline\">\\(x^n\\)</span> – это <span\nclass=\"math inline\">\\(\\underbrace{x\\ldots x}_{n}\\)</span>. <span\nclass=\"math inline\">\\(x^0 \\rightleftharpoons \\varepsilon\\)</span>.</p>\n<p>Множество всех слов в алфавите <span\nclass=\"math inline\">\\(\\Sigma\\)</span> обозначается <span\nclass=\"math inline\">\\(\\Sigma^{*}\\)</span>.</p>\n<p>Подмножества <span class=\"math inline\">\\(\\Sigma^{*}\\)</span> –\n<em>словарные множества</em> или <em>языки</em>.</p>",
        "statement_html": "",
        "proof_html": ""
    },
    {
        "keyword": "формальная теория сигнатура }$. элемент $\\operatorname{fm}$ --  .\n3. подмножество формул $\\operatorname{ax} \\subset \\operatorname{fm}$. элемент $\\operatorname{ax}$ --  .\n4. конечное множество отношений на формулах.\n\n  -- это отношение, определяющее принадлежность слова множеству формул.\n\n",
        "data": "**Определение:**<a name=\"definition-1\"></a> *Формальная теория* -- это \n\n1. Объединение алфавитов (конечных или счетных) -- $\\Sigma$. $\\Sigma$ -- *сигнатура*.\n2. Некоторое подмножество $\\operatorname{Fm} \\subset \\Sigma^{*}$. Элемент $\\operatorname{Fm}$ -- *формула*.\n3. Подмножество формул $\\operatorname{Ax} \\subset \\operatorname{Fm}$. Элемент $\\operatorname{Ax}$ -- *аксиома*.\n4. Конечное множество отношений на формулах.\n\n*Синтаксис* -- это отношение, определяющее принадлежность слова множеству формул.\n\n*Семантика* -- это отображение $\\operatorname{Fm} \\to ?$. ^[В множество значений, но его тут нет.]\n\n",
        "data_type": "definition",
        "url": "lection-predicate-logic-formal-languages.html#definition-1",
        "html": "<p><strong><a href=\"lection-predicate-logic-formal-languages.html#definition-1\">Определение:</a></strong>\n<em>Формальная теория</em> – это</p>\n<ol type=\"1\">\n<li>Объединение алфавитов (конечных или счетных) – <span\nclass=\"math inline\">\\(\\Sigma\\)</span>. <span\nclass=\"math inline\">\\(\\Sigma\\)</span> – <em>сигнатура</em>.</li>\n<li>Некоторое подмножество <span class=\"math inline\">\\(\\operatorname{Fm}\n\\subset \\Sigma^{*}\\)</span>. Элемент <span\nclass=\"math inline\">\\(\\operatorname{Fm}\\)</span> –\n<em>формула</em>.</li>\n<li>Подмножество формул <span class=\"math inline\">\\(\\operatorname{Ax}\n\\subset \\operatorname{Fm}\\)</span>. Элемент <span\nclass=\"math inline\">\\(\\operatorname{Ax}\\)</span> –\n<em>аксиома</em>.</li>\n<li>Конечное множество отношений на формулах.</li>\n</ol>\n<p><em>Синтаксис</em> – это отношение, определяющее принадлежность слова\nмножеству формул.</p>\n<p><em>Семантика</em> – это отображение <span\nclass=\"math inline\">\\(\\operatorname{Fm} \\to ?\\)</span>. <a href=\"#fn1\"\nclass=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a></p>\n<section id=\"footnotes\" class=\"footnotes footnotes-end-of-document\"\nrole=\"doc-endnotes\">\n<hr />\n<ol>\n<li id=\"fn1\"><p>В множество значений, но его тут нет.<a href=\"#fnref1\"\nclass=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n</ol>\n</section>",
        "statement_html": "",
        "proof_html": ""
    },
    {
        "keyword": "пропозициональные переменные пропозииональные связки формула формула формула формула формула",
        "data": "**Определение:**<a name=\"definition-5\"></a> \n\nПусть $\\operatorname{Var}$ -- алфавит. Его элементы (символы) -- *пропозициональные переменные*.\n\nПусть $\\operatorname{Prop} = \\{\\neg, \\vee, \\wedge, \\rightarrow, \\ldots\\}$ -- алфавит. Его элементы -- *пропозииональные связки*.\n\nПусть сигнатура -- это $\\operatorname{Var}\\cup \\operatorname{Prop} \\cup \\{«(», «)», «,»\\}$.\n\n*Формула* определяется индуктивно:\n\n1. $x \\in \\operatorname{Var}$ -- *формула*.\n2. $\\neg F$ -- *формула*, если $F$ -- формула.\n3. $F \\vee F’$ -- *формула*, если $F$ и $F’$ -- формулы.\n4. $F \\wedge F’$ -- *формула*, если $F$ и $F’$ -- формулы.\n\n",
        "data_type": "definition",
        "url": "lection-predicate-logic-formal-languages.html#definition-5",
        "html": "<p><strong><a href=\"lection-predicate-logic-formal-languages.html#definition-5\">Определение:</a></strong></p>\n<p>Пусть <span class=\"math inline\">\\(\\operatorname{Var}\\)</span> –\nалфавит. Его элементы (символы) – <em>пропозициональные\nпеременные</em>.</p>\n<p>Пусть <span class=\"math inline\">\\(\\operatorname{Prop} = \\{\\neg, \\vee,\n\\wedge, \\rightarrow, \\ldots\\}\\)</span> – алфавит. Его элементы –\n<em>пропозииональные связки</em>.</p>\n<p>Пусть сигнатура – это <span\nclass=\"math inline\">\\(\\operatorname{Var}\\cup \\operatorname{Prop} \\cup\n\\{«(», «)», «,»\\}\\)</span>.</p>\n<p><em>Формула</em> определяется индуктивно:</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(x \\in \\operatorname{Var}\\)</span> –\n<em>формула</em>.</li>\n<li><span class=\"math inline\">\\(\\neg F\\)</span> – <em>формула</em>, если\n<span class=\"math inline\">\\(F\\)</span> – формула.</li>\n<li><span class=\"math inline\">\\(F \\vee F’\\)</span> – <em>формула</em>,\nесли <span class=\"math inline\">\\(F\\)</span> и <span\nclass=\"math inline\">\\(F’\\)</span> – формулы.</li>\n<li><span class=\"math inline\">\\(F \\wedge F’\\)</span> – <em>формула</em>,\nесли <span class=\"math inline\">\\(F\\)</span> и <span\nclass=\"math inline\">\\(F’\\)</span> – формулы.</li>\n</ol>",
        "statement_html": "",
        "proof_html": ""
    },
    {
        "keyword": "универсум оценка значение при оценке",
        "data": "**Определение:**<a name=\"definition-4\"></a> \n\nПусть $U$ -- множество. $U$ -- *универсум*.\n\nОтображение $f: \\operatorname{Var} \\to \\mathcal{P}(U)$ -- *оценка*.\n\n*Значение* $f(A)$ формулы $A$ *при оценке* $f$ определеятся индуктивно:\n\n1. $f(\\neg A) = U \\setminus f(A)$.\n2. $f(A \\vee B) = f(A) \\cup f(B)$.\n3. $f(A \\wedge B) = f(A)\\cap f(B)$.\n\n",
        "data_type": "definition",
        "url": "lection-predicate-logic-formal-languages.html#definition-4",
        "html": "<p><strong><a href=\"lection-predicate-logic-formal-languages.html#definition-4\">Определение:</a></strong></p>\n<p>Пусть <span class=\"math inline\">\\(U\\)</span> – множество. <span\nclass=\"math inline\">\\(U\\)</span> – <em>универсум</em>.</p>\n<p>Отображение <span class=\"math inline\">\\(f: \\operatorname{Var} \\to\n\\mathcal{P}(U)\\)</span> – <em>оценка</em>.</p>\n<p><em>Значение</em> <span class=\"math inline\">\\(f(A)\\)</span> формулы\n<span class=\"math inline\">\\(A\\)</span> <em>при оценке</em> <span\nclass=\"math inline\">\\(f\\)</span> определеятся индуктивно:</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(f(\\neg A) = U \\setminus\nf(A)\\)</span>.</li>\n<li><span class=\"math inline\">\\(f(A \\vee B) = f(A) \\cup\nf(B)\\)</span>.</li>\n<li><span class=\"math inline\">\\(f(A \\wedge B) = f(A)\\cap\nf(B)\\)</span>.</li>\n</ol>",
        "statement_html": "",
        "proof_html": ""
    },
    {
        "keyword": "истина ложь истинная ложная   выполнимая тавтология тождественно истинная   равносильны   арный предикат на отношение арная функция на   предикатных символов функциональных символов констант индивидных предметных переменных сигнатура функция валентности язык сигнатуры терм терм терм атомарная формула (атом) формула формула формула формула формула формула формула формула формула   интерпретация универсум носитель интерпретации алгебраическая структура (модель) сигнатуры",
        "data": "**Определение:**<a name=\"definition-7\"></a> Возьмем $U = \\{1\\}$. Тогда $\\mathcal{P}(U) = \\{\\{1\\}, \\varnothing\\}$. Назовем $\\{1\\}$ -- *истина*, а $\\varnothing$ -- *ложь*.\n\nФормула *истинная*, если ее значение при оценке -- истина.\nФормула *ложная*, если ее значение при оценке -- ложь.\n\n[//]: # (end-definition-7)\n\n**Определение:**<a name=\"definition-2\"></a> Формула, истинная при какой-то оценке переменных, -- *выполнимая*.\n\nФормула, истинная при любой оценке переменных, -- *тавтология* или *тождественно истинная*.\n\n[//]: # (end-definition-2)\n\n**Определение:**<a name=\"definition-3\"></a> Формулы *равносильны*, если при каждой оценке переменных их значения совпадают.\n\n[//]: # (end-definition-3)\n\n# Логика предикатов первого порядка\n\n---\n\n**Определение:**<a name=\"definition-6\"></a> Пусть $M \\ne \\varnothing$.\n\n$Q \\subset M^n$ -- $n$-*арный предикат на* (*отношение*) $M$.\n\n$f: M^n \\to M$ -- $n$-*арная функция на* $M$.\n\n[//]: # (end-definition-6)\n\n## Синтаксис логики первого порядка\n\n---\n\n**Определение:**<a name=\"definition-8\"></a>\n\n$\\operatorname{Pred}_{\\Sigma} \\ne \\varnothing$ -- алфавит *предикатных символов*.\n\n$\\operatorname{Func}_{\\Sigma}$ -- алфавит *функциональных символов*.\n\n$\\operatorname{Const}_{\\Sigma}$ -- алфавит *констант*.\n\n$\\operatorname{Var}_{\\Sigma}$ -- алфавит *индивидных* или *предметных переменных*.\n\n*Сигнатура* -- это $\\Sigma = \\operatorname{Func}_{\\Sigma}\\cup \\operatorname{Pred}_{\\Sigma}\\cup\\operatorname{Const}_{\\Sigma}$ и *функция валентности*\n\n$$\\operatorname{arity}: \\operatorname{Func}_{\\Sigma} \\cup \\operatorname{Pred}_{\\Sigma} \\to \\mathbb{N} \\setminus \\{0\\},$$\n\nсопоставляющая каждому функциональному и предикатному символу количество его аргументов.\n\n*Язык сигнатуры* -- это $\\operatorname{Var}_{\\Sigma}\\cup \\{\\neg, \\vee, \\wedge, \\rightarrow, \\leftrightarrow, \\forall, \\exists, «(», «)», «,»\\}$\n\n*Терм* определяется идуктивно:\n\n1. Символ переменной или константы -- *терм*.\n2. Если $f \\in \\operatorname{Func}_{\\Sigma}, \\,\\,\\,\\, \\operatorname{arity}(f) = n$ и $t_1, \\ldots,t_n$ -- термы, то $f(t_1, \\ldots, t_n)$ -- *терм*.\n\n*Атомарная формула (атом)* -- это $p(t_1, \\ldots, t_n)$, где $p \\in \\operatorname{Pred}_{\\Sigma}, \\,\\,\\,\\, \\operatorname{arity}(p) = n$ и $t_1, \\ldots,t_n$ -- термы.\n\n*Формула* определяется индуктивно:\n\n1) Атом -- *формула*.\n2) Если $F$ и $F’$ -- формулы и $x \\in \\operatorname{Var}_{\\Sigma}$, то\n    - $\\neg F$ -- *формула*,\n    - $F \\vee F’$ -- *формула*,\n    - $F \\wedge F’$ -- *формула*,\n    - $F \\rightarrow F’$ -- *формула*,\n    - $F \\leftrightarrow F’$ -- *формула*,\n    - $\\forall x F$ -- *формула*,\n    - $\\exists x F$ -- *формула*.\n\n\n[//]: # (end-definition-8)\n\n## Сигнатура логики первого порядка\n\n---\n\n**Определение:**<a name=\"definition-7\"></a> Зафиксируем $U \\ne \\varnothing$.\n\nПусть $\\operatorname{I}: c_i \\mapsto \\overline{c}_i \\in U$,\n\n$\\operatorname{I}: P^n_i \\mapsto \\overline{P}^n_i \\in U, \\,\\,\\,\\, \\overline{P}^n_i \\subset U^n$,\n\n$\\operatorname{I}: f^n_i \\mapsto \\overline{f}^n_i \\in U, \\,\\,\\,\\, \\overline{f}^n_i: U^n \\to U$, где $c_i \\in \\operatorname{Const}_{\\Sigma}, \\,\\,\\,\\, P^n_i \\in \\operatorname{Pred}_{\\Sigma}$ и $\\operatorname{arity}(P^n_i) = n$, $f^n_i \\in \\operatorname{Func}_{\\Sigma}$ и $\\operatorname{arity}(f^n_i) = n$.\n\n$\\operatorname{I}$ -- *интерпретация* сигнатуры $\\Sigma$. $U$ -- *универсум* или *носитель интерпретации*.\n\n*Алгебраическая структура (модель) сигнатуры* $A_{\\Sigma}$ -- это интерпретация и универсум.\n\n",
        "data_type": "definition",
        "url": "lection-predicate-logic-formal-languages.html#definition-7",
        "html": "<p><strong><a href=\"lection-predicate-logic-formal-languages.html#definition-7\">Определение:</strong><a name=\"definition-7\"></a> Возьмем\n<span class=\"math inline\">\\(U = \\{1\\}\\)</span>. Тогда <span\nclass=\"math inline\">\\(\\mathcal{P}(U) = \\{\\{1\\}, \\varnothing\\}\\)</span>.\nНазовем <span class=\"math inline\">\\(\\{1\\}\\)</span> – <em>истина</em>, а\n<span class=\"math inline\">\\(\\varnothing\\)</span> – <em>ложь</em>.</p>\n<p>Формула <em>истинная</em>, если ее значение при оценке – истина.\nФормула <em>ложная</em>, если ее значение при оценке – ложь.</p>\n<p><strong>Определение:</strong><a name=\"definition-2\"></a> Формула,\nистинная при какой-то оценке переменных, – <em>выполнимая</em>.</p>\n<p>Формула, истинная при любой оценке переменных, – <em>тавтология</em>\nили <em>тождественно истинная</em>.</p>\n<p><strong>Определение:</strong><a name=\"definition-3\"></a> Формулы\n<em>равносильны</em>, если при каждой оценке переменных их значения\nсовпадают.</p>\n<h1 id=\"логика-предикатов-первого-порядка\">Логика предикатов первого\nпорядка</h1>\n<hr />\n<p><strong>Определение:</strong><a name=\"definition-6\"></a> Пусть <span\nclass=\"math inline\">\\(M \\ne \\varnothing\\)</span>.</p>\n<p><span class=\"math inline\">\\(Q \\subset M^n\\)</span> – <span\nclass=\"math inline\">\\(n\\)</span>-<em>арный предикат на</em>\n(<em>отношение</em>) <span class=\"math inline\">\\(M\\)</span>.</p>\n<p><span class=\"math inline\">\\(f: M^n \\to M\\)</span> – <span\nclass=\"math inline\">\\(n\\)</span>-<em>арная функция на</em> <span\nclass=\"math inline\">\\(M\\)</span>.</p>\n<h2 id=\"синтаксис-логики-первого-порядка\">Синтаксис логики первого\nпорядка</h2>\n<hr />\n<p><strong>Определение:</strong><a name=\"definition-8\"></a></p>\n<p><span class=\"math inline\">\\(\\operatorname{Pred}_{\\Sigma} \\ne\n\\varnothing\\)</span> – алфавит <em>предикатных символов</em>.</p>\n<p><span class=\"math inline\">\\(\\operatorname{Func}_{\\Sigma}\\)</span> –\nалфавит <em>функциональных символов</em>.</p>\n<p><span class=\"math inline\">\\(\\operatorname{Const}_{\\Sigma}\\)</span> –\nалфавит <em>констант</em>.</p>\n<p><span class=\"math inline\">\\(\\operatorname{Var}_{\\Sigma}\\)</span> –\nалфавит <em>индивидных</em> или <em>предметных переменных</em>.</p>\n<p><em>Сигнатура</em> – это <span class=\"math inline\">\\(\\Sigma =\n\\operatorname{Func}_{\\Sigma}\\cup\n\\operatorname{Pred}_{\\Sigma}\\cup\\operatorname{Const}_{\\Sigma}\\)</span> и\n<em>функция валентности</em></p>\n<p><span class=\"math display\">\\[\\operatorname{arity}:\n\\operatorname{Func}_{\\Sigma} \\cup \\operatorname{Pred}_{\\Sigma} \\to\n\\mathbb{N} \\setminus \\{0\\},\\]</span></p>\n<p>сопоставляющая каждому функциональному и предикатному символу\nколичество его аргументов.</p>\n<p><em>Язык сигнатуры</em> – это <span\nclass=\"math inline\">\\(\\operatorname{Var}_{\\Sigma}\\cup \\{\\neg, \\vee,\n\\wedge, \\rightarrow, \\leftrightarrow, \\forall, \\exists, «(», «)»,\n«,»\\}\\)</span></p>\n<p><em>Терм</em> определяется идуктивно:</p>\n<ol type=\"1\">\n<li>Символ переменной или константы – <em>терм</em>.</li>\n<li>Если <span class=\"math inline\">\\(f \\in \\operatorname{Func}_{\\Sigma},\n\\,\\,\\,\\, \\operatorname{arity}(f) = n\\)</span> и <span\nclass=\"math inline\">\\(t_1, \\ldots,t_n\\)</span> – термы, то <span\nclass=\"math inline\">\\(f(t_1, \\ldots, t_n)\\)</span> – <em>терм</em>.</li>\n</ol>\n<p><em>Атомарная формула (атом)</em> – это <span\nclass=\"math inline\">\\(p(t_1, \\ldots, t_n)\\)</span>, где <span\nclass=\"math inline\">\\(p \\in \\operatorname{Pred}_{\\Sigma}, \\,\\,\\,\\,\n\\operatorname{arity}(p) = n\\)</span> и <span class=\"math inline\">\\(t_1,\n\\ldots,t_n\\)</span> – термы.</p>\n<p><em>Формула</em> определяется индуктивно:</p>\n<ol type=\"1\">\n<li>Атом – <em>формула</em>.</li>\n<li>Если <span class=\"math inline\">\\(F\\)</span> и <span\nclass=\"math inline\">\\(F’\\)</span> – формулы и <span\nclass=\"math inline\">\\(x \\in \\operatorname{Var}_{\\Sigma}\\)</span>, то\n<ul>\n<li><span class=\"math inline\">\\(\\neg F\\)</span> – <em>формула</em>,</li>\n<li><span class=\"math inline\">\\(F \\vee F’\\)</span> –\n<em>формула</em>,</li>\n<li><span class=\"math inline\">\\(F \\wedge F’\\)</span> –\n<em>формула</em>,</li>\n<li><span class=\"math inline\">\\(F \\rightarrow F’\\)</span> –\n<em>формула</em>,</li>\n<li><span class=\"math inline\">\\(F \\leftrightarrow F’\\)</span> –\n<em>формула</em>,</li>\n<li><span class=\"math inline\">\\(\\forall x F\\)</span> –\n<em>формула</em>,</li>\n<li><span class=\"math inline\">\\(\\exists x F\\)</span> –\n<em>формула</em>.</li>\n</ul></li>\n</ol>\n<h2 id=\"сигнатура-логики-первого-порядка\">Сигнатура логики первого\nпорядка</h2>\n<hr />\n<p><strong>Определение:</a></strong> Зафиксируем\n<span class=\"math inline\">\\(U \\ne \\varnothing\\)</span>.</p>\n<p>Пусть <span class=\"math inline\">\\(\\operatorname{I}: c_i \\mapsto\n\\overline{c}_i \\in U\\)</span>,</p>\n<p><span class=\"math inline\">\\(\\operatorname{I}: P^n_i \\mapsto\n\\overline{P}^n_i \\in U, \\,\\,\\,\\, \\overline{P}^n_i \\subset\nU^n\\)</span>,</p>\n<p><span class=\"math inline\">\\(\\operatorname{I}: f^n_i \\mapsto\n\\overline{f}^n_i \\in U, \\,\\,\\,\\, \\overline{f}^n_i: U^n \\to U\\)</span>,\nгде <span class=\"math inline\">\\(c_i \\in \\operatorname{Const}_{\\Sigma},\n\\,\\,\\,\\, P^n_i \\in \\operatorname{Pred}_{\\Sigma}\\)</span> и <span\nclass=\"math inline\">\\(\\operatorname{arity}(P^n_i) = n\\)</span>, <span\nclass=\"math inline\">\\(f^n_i \\in \\operatorname{Func}_{\\Sigma}\\)</span> и\n<span class=\"math inline\">\\(\\operatorname{arity}(f^n_i) =\nn\\)</span>.</p>\n<p><span class=\"math inline\">\\(\\operatorname{I}\\)</span> –\n<em>интерпретация</em> сигнатуры <span\nclass=\"math inline\">\\(\\Sigma\\)</span>. <span\nclass=\"math inline\">\\(U\\)</span> – <em>универсум</em> или <em>носитель\nинтерпретации</em>.</p>\n<p><em>Алгебраическая структура (модель) сигнатуры</em> <span\nclass=\"math inline\">\\(A_{\\Sigma}\\)</span> – это интерпретация и\nуниверсум.</p>",
        "statement_html": "",
        "proof_html": ""
    },
    {
        "keyword": "область действия квантора связанная переменная свободная переменная замкнутая   оценка переменных контекст   общезначима эквивалентны",
        "data": "**Определение:**<a name=\"definition-12\"></a> Пусть $\\varphi$ - формула. В формулах $(\\forall x \\varphi)$ и $(\\exists x \\varphi) \\,\\,\\,\\, \\varphi$ - это *область действия квантора*.\n\nЕсли $\\varphi$ содержит $x \\in \\operatorname{Var}_{\\Sigma}$, то $x$ - *связанная переменная*.\n\nИначе $x$ - *свободная переменная*.\n\nФормула *замкнутая*, если в ней нет свободных переменных.\n\n[//]: # (end-definition-12)\n\n**Определение:**<a name=\"definition-11\"></a> \n\nОтображение $\\theta: \\operatorname{Var}_{\\Sigma} \\to U$ - *оценка переменных* или *контекст*.\n\nБескванторная формула при заданной оценке переменных - это формула логики высказываний и можно определить ее [истинность](#definition-7).\n\nФормула $(\\exists x \\varphi)$ истинна, если существует контекст, в котором формула $\\varphi$ - истинна.\n\nФормула $(\\forall x \\varphi)$ истинна, если $\\varphi$ истинна в любом контексте.\n\nИстинность формулы $\\varphi$ в контексте $\\theta$ в алгебраической структуре $A_{\\Sigma}$ обозначается $A_{\\Sigma}, \\theta \\models \\varphi$.\n\n[//]: # (end-definition-11)\n\n**Определение:**<a name=\"definition-12\"></a> Формула $\\varphi$ *общезначима*, если $\\varphi$ истинна в любой алгебраической структуре в любом контексте. Обозначается: $\\models \\varphi$.\n\nФормулы $\\varphi$ и $\\psi$ *эквивалентны*, если $\\models \\varphi \\to \\psi$ и $\\models \\psi \\to \\varphi$.\n\n",
        "data_type": "definition",
        "url": "lection-predicate-logic-formal-languages.html#definition-12",
        "html": "<p><strong><a href=\"lection-predicate-logic-formal-languages.html#definition-12\">Определение:</strong><a name=\"definition-12\"></a> Пусть <span\nclass=\"math inline\">\\(\\varphi\\)</span> - формула. В формулах <span\nclass=\"math inline\">\\((\\forall x \\varphi)\\)</span> и <span\nclass=\"math inline\">\\((\\exists x \\varphi) \\,\\,\\,\\, \\varphi\\)</span> -\nэто <em>область действия квантора</em>.</p>\n<p>Если <span class=\"math inline\">\\(\\varphi\\)</span> содержит <span\nclass=\"math inline\">\\(x \\in \\operatorname{Var}_{\\Sigma}\\)</span>, то\n<span class=\"math inline\">\\(x\\)</span> - <em>связанная\nпеременная</em>.</p>\n<p>Иначе <span class=\"math inline\">\\(x\\)</span> - <em>свободная\nпеременная</em>.</p>\n<p>Формула <em>замкнутая</em>, если в ней нет свободных переменных.</p>\n<p><strong>Определение:</strong><a name=\"definition-11\"></a></p>\n<p>Отображение <span class=\"math inline\">\\(\\theta:\n\\operatorname{Var}_{\\Sigma} \\to U\\)</span> - <em>оценка переменных</em>\nили <em>контекст</em>.</p>\n<p>Бескванторная формула при заданной оценке переменных - это формула\nлогики высказываний и можно определить ее <a\nhref=\"#definition-7\">истинность</a>.</p>\n<p>Формула <span class=\"math inline\">\\((\\exists x \\varphi)\\)</span>\nистинна, если существует контекст, в котором формула <span\nclass=\"math inline\">\\(\\varphi\\)</span> - истинна.</p>\n<p>Формула <span class=\"math inline\">\\((\\forall x \\varphi)\\)</span>\nистинна, если <span class=\"math inline\">\\(\\varphi\\)</span> истинна в\nлюбом контексте.</p>\n<p>Истинность формулы <span class=\"math inline\">\\(\\varphi\\)</span> в\nконтексте <span class=\"math inline\">\\(\\theta\\)</span> в алгебраической\nструктуре <span class=\"math inline\">\\(A_{\\Sigma}\\)</span> обозначается\n<span class=\"math inline\">\\(A_{\\Sigma}, \\theta \\models\n\\varphi\\)</span>.</p>\n<p><strong>Определение:</a></strong> Формула\n<span class=\"math inline\">\\(\\varphi\\)</span> <em>общезначима</em>, если\n<span class=\"math inline\">\\(\\varphi\\)</span> истинна в любой\nалгебраической структуре в любом контексте. Обозначается: <span\nclass=\"math inline\">\\(\\models \\varphi\\)</span>.</p>\n<p>Формулы <span class=\"math inline\">\\(\\varphi\\)</span> и <span\nclass=\"math inline\">\\(\\psi\\)</span> <em>эквивалентны</em>, если <span\nclass=\"math inline\">\\(\\models \\varphi \\to \\psi\\)</span> и <span\nclass=\"math inline\">\\(\\models \\psi \\to \\varphi\\)</span>.</p>",
        "statement_html": "",
        "proof_html": ""
    },
    {
        "keyword": "пропозициональный язык (сигнатура) пропозициональных переменных возможность необходимость",
        "data": "**Определение:**<a name=\"definition-0\"></a> \n\n*Пропозициональный язык (сигнатура)* - это \n\n1) Множество *пропозициональных переменных*: $\\operatorname{Prop} = \\{P_1, P_2, \\ldots\\}$,\n2) Логические связки: $\\neg, \\vee, \\wedge, \\rightarrow$,\n3) Модальности: $\\Diamond$ и $\\Box$ (*возможность* и *необходимость*),\n4) Скобки: $($, $)$.\n\nФормулы определяются как и везде.\n\n",
        "data_type": "definition",
        "url": "lection-modal-logic.html#definition-0",
        "html": "<p><strong><a href=\"lection-modal-logic.html#definition-0\">Определение:</a></strong></p>\n<p><em>Пропозициональный язык (сигнатура)</em> - это</p>\n<ol type=\"1\">\n<li>Множество <em>пропозициональных переменных</em>: <span\nclass=\"math inline\">\\(\\operatorname{Prop} = \\{P_1, P_2,\n\\ldots\\}\\)</span>,</li>\n<li>Логические связки: <span class=\"math inline\">\\(\\neg, \\vee, \\wedge,\n\\rightarrow\\)</span>,</li>\n<li>Модальности: <span class=\"math inline\">\\(\\Diamond\\)</span> и <span\nclass=\"math inline\">\\(\\Box\\)</span> (<em>возможность</em> и\n<em>необходимость</em>),</li>\n<li>Скобки: <span class=\"math inline\">\\((\\)</span>, <span\nclass=\"math inline\">\\()\\)</span>.</li>\n</ol>\n<p>Формулы определяются как и везде.</p>",
        "statement_html": "",
        "proof_html": ""
    },
    {
        "keyword": "шкала крипке мир достижим из истинностная оценка в шкале модель крипке истинна в мире",
        "data": "**Определение:**<a name=\"definition-1\"></a> \n\nСемантика модальной логики - это модули Крипке.\n\n*Шкала Крипке* - это непустое множество $W$ и бинарное отношение $R \\subset W\\times W$ на $W$.\n\nЭлемент $W$ - *мир*. Если $\\langle w_1, w_2 \\rangle \\in R$, то $w_2$ *достижим из* $w_1$.\n\nШкала Крипке обозначается: $F = (W, R)$.\n\nОтображение $v: W \\times \\operatorname{Prop} \\to \\{0, 1\\}$ - *истинностная оценка в шкале* $F$.\n\n*Модель Крипке* - это $K = (W, R, v)$.\n\n### Истинность:\n\n1) Пропозиционная переменная $\\varphi$ *истинна в мире* $w \\in W$ модели Крипке $K$, если $v(x, P_i) = 1$,\n\n2) Истинность формулы, содержащей $\\neg, \\vee, \\wedge, \\rightarrow$ определяется по таблицам,\n\n3) $K, w \\models \\Box \\varphi \\rightleftharpoons \\forall w’ \\in R(w) \\,\\,\\,\\, K, w’ \\models \\varphi$,\n\n4) $K, w \\models \\Diamond \\varphi \\rightleftharpoons \\exists w’ \\in R(w) \\,\\,\\,\\, K, w’ \\models \\varphi$.\n\n\nИстинность формулы $\\varphi$ в мире $w \\in W$ модели $K = (W, R, v)$ обозначается: $w \\models \\varphi$.\n\n",
        "data_type": "definition",
        "url": "lection-modal-logic.html#definition-1",
        "html": "<p><strong><a href=\"lection-modal-logic.html#definition-1\">Определение:</a></strong></p>\n<p>Семантика модальной логики - это модули Крипке.</p>\n<p><em>Шкала Крипке</em> - это непустое множество <span\nclass=\"math inline\">\\(W\\)</span> и бинарное отношение <span\nclass=\"math inline\">\\(R \\subset W\\times W\\)</span> на <span\nclass=\"math inline\">\\(W\\)</span>.</p>\n<p>Элемент <span class=\"math inline\">\\(W\\)</span> - <em>мир</em>. Если\n<span class=\"math inline\">\\(\\langle w_1, w_2 \\rangle \\in R\\)</span>, то\n<span class=\"math inline\">\\(w_2\\)</span> <em>достижим из</em> <span\nclass=\"math inline\">\\(w_1\\)</span>.</p>\n<p>Шкала Крипке обозначается: <span class=\"math inline\">\\(F = (W,\nR)\\)</span>.</p>\n<p>Отображение <span class=\"math inline\">\\(v: W \\times\n\\operatorname{Prop} \\to \\{0, 1\\}\\)</span> - <em>истинностная оценка в\nшкале</em> <span class=\"math inline\">\\(F\\)</span>.</p>\n<p><em>Модель Крипке</em> - это <span class=\"math inline\">\\(K = (W, R,\nv)\\)</span>.</p>\n<h3 id=\"истинность\">Истинность:</h3>\n<ol type=\"1\">\n<li><p>Пропозиционная переменная <span\nclass=\"math inline\">\\(\\varphi\\)</span> <em>истинна в мире</em> <span\nclass=\"math inline\">\\(w \\in W\\)</span> модели Крипке <span\nclass=\"math inline\">\\(K\\)</span>, если <span class=\"math inline\">\\(v(x,\nP_i) = 1\\)</span>,</p></li>\n<li><p>Истинность формулы, содержащей <span class=\"math inline\">\\(\\neg,\n\\vee, \\wedge, \\rightarrow\\)</span> определяется по таблицам,</p></li>\n<li><p><span class=\"math inline\">\\(K, w \\models \\Box \\varphi\n\\rightleftharpoons \\forall w’ \\in R(w) \\,\\,\\,\\, K, w’ \\models\n\\varphi\\)</span>,</p></li>\n<li><p><span class=\"math inline\">\\(K, w \\models \\Diamond \\varphi\n\\rightleftharpoons \\exists w’ \\in R(w) \\,\\,\\,\\, K, w’ \\models\n\\varphi\\)</span>.</p></li>\n</ol>\n<p>Истинность формулы <span class=\"math inline\">\\(\\varphi\\)</span> в\nмире <span class=\"math inline\">\\(w \\in W\\)</span> модели <span\nclass=\"math inline\">\\(K = (W, R, v)\\)</span> обозначается: <span\nclass=\"math inline\">\\(w \\models \\varphi\\)</span>.</p>",
        "statement_html": "",
        "proof_html": ""
    },
    {
        "keyword": "доказательство:",
        "data": "**Утверждение:**<a name=\"statement-1\"></a> $F \\models \\Box p \\to p \\iff F$ - рефлексивна, то есть $xRx \\,\\,\\,\\, \\forall x \\in W$.\n\n*Доказательство:*\n\n",
        "data_type": "statement",
        "url": "lection-modal-logic.html#statement-1",
        "html": "<p><strong><a href=\"lection-modal-logic.html#statement-1\">Утверждение:</a></strong> <span\nclass=\"math inline\">\\(F \\models \\Box p \\to p \\iff F\\)</span> -\nрефлексивна, то есть <span class=\"math inline\">\\(xRx \\,\\,\\,\\, \\forall x\n\\in W\\)</span>.</p>\n<p><em>Доказательство:</em></p>",
        "statement_html": "<p><strong><a href=\"lection-modal-logic.html#statement-1\">Утверждение:</a></strong> <span\nclass=\"math inline\">\\(F \\models \\Box p \\to p \\iff F\\)</span> -\nрефлексивна, то есть <span class=\"math inline\">\\(xRx \\,\\,\\,\\, \\forall x\n\\in W\\)</span>.</p>",
        "proof_html": "<p></p>"
    },
    {
        "keyword": "доказательство:",
        "data": "**Утверждение:**<a name=\"statement-2\"></a> $F \\models p \\to \\Box\\Diamond p \\iff F$ - симметрична, то есть $xRy \\rightarrow yRx \\,\\,\\,\\, \\forall x, y \\in W$.\n\n*Доказательство:*\n\n",
        "data_type": "statement",
        "url": "lection-modal-logic.html#statement-2",
        "html": "<p><strong><a href=\"lection-modal-logic.html#statement-2\">Утверждение:</a></strong> <span\nclass=\"math inline\">\\(F \\models p \\to \\Box\\Diamond p \\iff F\\)</span> -\nсимметрична, то есть <span class=\"math inline\">\\(xRy \\rightarrow yRx\n\\,\\,\\,\\, \\forall x, y \\in W\\)</span>.</p>\n<p><em>Доказательство:</em></p>",
        "statement_html": "<p><strong><a href=\"lection-modal-logic.html#statement-2\">Утверждение:</a></strong> <span\nclass=\"math inline\">\\(F \\models p \\to \\Box\\Diamond p \\iff F\\)</span> -\nсимметрична, то есть <span class=\"math inline\">\\(xRy \\rightarrow yRx\n\\,\\,\\,\\, \\forall x, y \\in W\\)</span>.</p>",
        "proof_html": "<p></p>"
    },
    {
        "keyword": "доказательство:",
        "data": "**Утверждение:**<a name=\"statement-0\"></a> $F \\models \\Box p \\to \\Box\\Box p \\iff F$ - транзитивна, то есть $xRy \\wedge yRz \\rightarrow xRz \\,\\,\\,\\, \\forall x, y, z \\in W$.\n\n*Доказательство:*\n\n",
        "data_type": "statement",
        "url": "lection-modal-logic.html#statement-0",
        "html": "<p><strong><a href=\"lection-modal-logic.html#statement-0\">Утверждение:</a></strong> <span\nclass=\"math inline\">\\(F \\models \\Box p \\to \\Box\\Box p \\iff F\\)</span> -\nтранзитивна, то есть <span class=\"math inline\">\\(xRy \\wedge yRz\n\\rightarrow xRz \\,\\,\\,\\, \\forall x, y, z \\in W\\)</span>.</p>\n<p><em>Доказательство:</em></p>",
        "statement_html": "<p><strong><a href=\"lection-modal-logic.html#statement-0\">Утверждение:</a></strong> <span\nclass=\"math inline\">\\(F \\models \\Box p \\to \\Box\\Box p \\iff F\\)</span> -\nтранзитивна, то есть <span class=\"math inline\">\\(xRy \\wedge yRz\n\\rightarrow xRz \\,\\,\\,\\, \\forall x, y, z \\in W\\)</span>.</p>",
        "proof_html": "<p></p>"
    }
]